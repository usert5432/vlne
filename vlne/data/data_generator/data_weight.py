"""
A definition of a decorator that modifies weights in a batch.
"""

import numpy as np

from .idata_decorator  import IDataDecorator

class DataWeight(IDataDecorator):
    """A decorator around `IDataGenerator` that modifies target weights.

    This decorator will calculate weights for each sample. Then it will
    use calculated weights to modify target weights in each batch generated
    by `dgen`. Old weights in a batch will be multiplied by the weights
    calculated by `DataWeight`.

    Parameters
    ----------
    dgen : IDataGenerator
        `IDataGenerator` to be decorated.
    batch_size : int
        Size of batches that will be generated by `dgen`.
    weights : str or callable or None
        Weight specification.
        If None then weights generated by `dgen` will not be modified.
        If str then it will use values of variable named `weights` obtained
        from `dgen.data_loader` as weights.
        If callable, then it will use `weights(dgen.data_loader)` in order to
        calculate weights.
    """

    def __init__(self, dgen, batch_size, weights):
        super(DataWeight, self).__init__(dgen)
        self._batch_size = batch_size
        self._weights    = weights

        self._init_weights()

    def _init_weights(self):

        if isinstance(self._weights, np.ndarray):
            return

        if isinstance(self._weights, str):
            self._weights = self.data_loader.get(self._weights).ravel()

        elif callable(self._weights):
            self._weights = self._weights(self.data_loader)

        elif self._weights is None:
            # NOTE: This is to make downstream algorithms easier
            self._weights = np.ones(len(self.data_loader))

        else:
            raise RuntimeError("Unknown weights: %s" % (self._weights))

    def __getitem__(self, index):
        inputs, targets, weights = self._dgen[index]

        start = index * self._batch_size
        end   = min((index + 1) * self._batch_size, len(self.data_loader))

        sample_weights = self._weights[start:end]

        return (inputs, targets, [ x * sample_weights for x in weights ])

    @property
    def weights(self):
        return self._dgen.weights * self._weights

